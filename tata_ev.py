# -*- coding: utf-8 -*-
"""TATA-EV

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pyqCQalIHjBeOdSTLvo72goFpzi5K0rV
"""

!pip install -q folium
!pip install -q openai
!pip install -q geopy
!pip install -q requests
!pip install -q scikit-learn

# Import all necessary modules
import requests
import folium
from geopy.distance import geodesic
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt
from IPython.display import display

# Insert your Google Maps API Key here
GOOGLE_MAPS_API_KEY = "AIzaSyBZnVIHPydIZz1JRfRk59fhoXYpFTHWxyA"

def get_lat_lon(place, api_key):
    url = f"https://maps.googleapis.com/maps/api/geocode/json?address={place}&key={api_key}"
    response = requests.get(url)
    data = response.json()
    if data['status'] == 'OK':
        location = data['results'][0]['geometry']['location']
        return (location['lat'], location['lng'])
    else:
        raise ValueError(f"Geocoding failed for {place}")

def get_route_polyline(start, end, api_key):
    url = f"https://maps.googleapis.com/maps/api/directions/json?origin={start}&destination={end}&key={api_key}"
    response = requests.get(url)
    data = response.json()
    if data['status'] == 'OK':
        polyline = data['routes'][0]['overview_polyline']['points']
        return polyline
    else:
        raise ValueError("Route fetching failed")

!pip install -q polyline
import polyline

def decode_polyline(encoded_polyline):
    return polyline.decode(encoded_polyline)

def plot_route_on_map(route_coords, start_coord, end_coord):
    midpoint = route_coords[len(route_coords)//2]
    m = folium.Map(location=midpoint, zoom_start=10)

    folium.Marker(location=start_coord, popup='Start', icon=folium.Icon(color='green')).add_to(m)
    folium.Marker(location=end_coord, popup='End', icon=folium.Icon(color='red')).add_to(m)
    folium.PolyLine(locations=route_coords, color='blue', weight=5).add_to(m)

    return m

import requests

def get_coordinates_nominatim(place):
    url = f"https://nominatim.openstreetmap.org/search?q={place}&format=json&limit=1"
    response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
    data = response.json()
    if data:
        return float(data[0]['lat']), float(data[0]['lon'])
    else:
        raise ValueError(f"Location not found: {place}")

def get_osrm_route(start_coord, end_coord):
    base_url = "http://router.project-osrm.org/route/v1/driving/"
    coordinates = f"{start_coord[1]},{start_coord[0]};{end_coord[1]},{end_coord[0]}"
    url = f"{base_url}{coordinates}?overview=full&geometries=geojson"
    response = requests.get(url)
    data = response.json()
    route_coords = data['routes'][0]['geometry']['coordinates']
    # Convert from [lon, lat] to [lat, lon] for Folium
    return [[lat, lon] for lon, lat in route_coords]

import folium

def plot_route(route_coords, start_coord, end_coord):
    midpoint = route_coords[len(route_coords)//2]
    m = folium.Map(location=midpoint, zoom_start=10)

    folium.Marker(location=start_coord, popup="Start", icon=folium.Icon(color='green')).add_to(m)
    folium.Marker(location=end_coord, popup="End", icon=folium.Icon(color='red')).add_to(m)
    folium.PolyLine(locations=route_coords, color='blue', weight=5).add_to(m)

    return m

def get_ev_stations_near(lat, lon, radius_km=10):
    overpass_url = "http://overpass-api.de/api/interpreter"
    query = f"""
    [out:json];
    node
      ["amenity"="charging_station"]
      (around:{radius_km*1000},{lat},{lon});
    out;
    """
    response = requests.post(overpass_url, data={'data': query})
    data = response.json()
    stations = [(node['lat'], node['lon']) for node in data['elements']]
    return stations

!pip install -q folium geopy requests

import requests
import folium
from geopy.distance import geodesic

def get_coordinates(place):
    url = f"https://nominatim.openstreetmap.org/search?q={place}&format=json&limit=1"
    response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
    data = response.json()
    if data:
        return float(data[0]['lat']), float(data[0]['lon'])
    else:
        raise ValueError(f"Location not found: {place}")

def get_osrm_route(start_coord, end_coord):
    base_url = "http://router.project-osrm.org/route/v1/driving/"
    coordinates = f"{start_coord[1]},{start_coord[0]};{end_coord[1]},{end_coord[0]}"
    url = f"{base_url}{coordinates}?overview=full&geometries=geojson"
    response = requests.get(url)
    data = response.json()
    route_coords = data['routes'][0]['geometry']['coordinates']
    # Convert [lon, lat] to [lat, lon] for Folium
    return [[lat, lon] for lon, lat in route_coords]

def get_ev_stations_near(lat, lon, radius_km=10):
    overpass_url = "http://overpass-api.de/api/interpreter"
    query = f"""
    [out:json];
    node
      ["amenity"="charging_station"]
      (around:{radius_km*1000},{lat},{lon});
    out;
    """
    response = requests.post(overpass_url, data={'data': query})
    data = response.json()
    stations = [(node['lat'], node['lon']) for node in data['elements']]
    return stations

def plot_route(route_coords, start_coord, end_coord, stations):
    midpoint = route_coords[len(route_coords)//2]
    m = folium.Map(location=midpoint, zoom_start=10)

    folium.Marker(location=start_coord, popup="Start", icon=folium.Icon(color='green')).add_to(m)
    folium.Marker(location=end_coord, popup="End", icon=folium.Icon(color='red')).add_to(m)

    # Draw route
    folium.PolyLine(locations=route_coords, color='blue', weight=5).add_to(m)

    # Plot charging stations
    for station in stations:
        folium.Marker(location=station, icon=folium.Icon(color='orange', icon='bolt'), popup='EV Charger').add_to(m)

    return m

# User input
start = "Bangalore"
end = "Mysore"

# Get coordinates
start_coord = get_coordinates(start)
end_coord = get_coordinates(end)

# Get route and stations
route_coords = get_osrm_route(start_coord, end_coord)
stations = get_ev_stations_near(route_coords[len(route_coords)//2][0], route_coords[len(route_coords)//2][1], radius_km=10)

# Plot map
map_obj = plot_route(route_coords, start_coord, end_coord, stations)
map_obj

def get_all_stations_along_route(route_coords, interval=20, radius_km=10):
    sampled_stations = set()

    for i in range(0, len(route_coords), interval):
        lat, lon = route_coords[i]
        try:
            stations = get_ev_stations_near(lat, lon, radius_km)
            for s in stations:
                sampled_stations.add((round(s[0], 5), round(s[1], 5)))  # Remove duplicates
        except:
            continue

    return list(sampled_stations)

# Step 3: Convert place name to coordinates using Nominatim
def get_coordinates(place):
    url = f"https://nominatim.openstreetmap.org/search?q={place}&format=json&limit=1"
    response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
    data = response.json()
    if data:
        return float(data[0]['lat']), float(data[0]['lon'])
    else:
        raise ValueError(f"Location not found: {place}")

# Step 4: Fetch shortest route using OSRM
def get_osrm_route(start_coord, end_coord):
    base_url = "http://router.project-osrm.org/route/v1/driving/"
    coordinates = f"{start_coord[1]},{start_coord[0]};{end_coord[1]},{end_coord[0]}"
    url = f"{base_url}{coordinates}?overview=full&geometries=geojson"
    response = requests.get(url)
    data = response.json()
    route_coords = data['routes'][0]['geometry']['coordinates']
    # Convert from [lon, lat] to [lat, lon]
    return [[lat, lon] for lon, lat in route_coords]

# Step 5: Find charging stations near a given point using Overpass API
def get_ev_stations_near(lat, lon, radius_km=10):
    overpass_url = "http://overpass-api.de/api/interpreter"
    query = f"""
    [out:json];
    node
      ["amenity"="charging_station"]
      (around:{radius_km * 1000},{lat},{lon});
    out;
    """
    response = requests.post(overpass_url, data={'data': query})
    data = response.json()
    stations = [(node['lat'], node['lon']) for node in data['elements']]
    return stations

# Step 5: Find charging stations near a given point using Overpass API
def get_ev_stations_near(lat, lon, radius_km=10):
    overpass_url = "http://overpass-api.de/api/interpreter"
    query = f"""
    [out:json];
    node
      ["amenity"="charging_station"]
      (around:{radius_km * 1000},{lat},{lon});
    out;
    """
    response = requests.post(overpass_url, data={'data': query})
    data = response.json()
    stations = [(node['lat'], node['lon']) for node in data['elements']]
    return stations

# Step 6: Scan route and find charging stations at regular intervals
def get_all_stations_along_route(route_coords, interval=20, radius_km=10):
    sampled_stations = set()

    for i in range(0, len(route_coords), interval):
        lat, lon = route_coords[i]
        try:
            stations = get_ev_stations_near(lat, lon, radius_km)
            for s in stations:
                sampled_stations.add((round(s[0], 5), round(s[1], 5)))
        except:
            continue

    return list(sampled_stations)

# Step 7: Display route and charging stations on interactive map
def plot_route(route_coords, start_coord, end_coord, stations):
    midpoint = route_coords[len(route_coords)//2]
    m = folium.Map(location=midpoint, zoom_start=10)

    folium.Marker(location=start_coord, popup="Start", icon=folium.Icon(color='green')).add_to(m)
    folium.Marker(location=end_coord, popup="End", icon=folium.Icon(color='red')).add_to(m)

    # Route
    folium.PolyLine(locations=route_coords, color='blue', weight=5).add_to(m)

    # Charging stations
    for station in stations:
        folium.Marker(location=station, icon=folium.Icon(color='orange'), popup='EV Charger').add_to(m)

    return m

# Step 8: Main execution

# You can change these locations
start = "Bangalore"
end = "Mysore"

# Get coordinates
start_coord = get_coordinates(start)
end_coord = get_coordinates(end)

# Get route
route_coords = get_osrm_route(start_coord, end_coord)

# Find EV charging stations along route
stations = get_all_stations_along_route(route_coords, interval=20, radius_km=10)
print(f"{len(stations)} charging stations found along the route.")

# Plot
map_obj = plot_route(route_coords, start_coord, end_coord, stations)
map_obj

!pip install -q folium geopy requests scikit-learn

import requests
import folium
from geopy.distance import geodesic
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

def get_coordinates(place):
    url = f"https://nominatim.openstreetmap.org/search?q={place}&format=json&limit=1"
    response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
    data = response.json()
    if data:
        return float(data[0]['lat']), float(data[0]['lon'])
    else:
        raise ValueError(f"Location not found: {place}")

def get_osrm_route(start_coord, end_coord):
    base_url = "http://router.project-osrm.org/route/v1/driving/"
    coordinates = f"{start_coord[1]},{start_coord[0]};{end_coord[1]},{end_coord[0]}"
    url = f"{base_url}{coordinates}?overview=full&geometries=geojson"
    response = requests.get(url)
    data = response.json()
    route_coords = data['routes'][0]['geometry']['coordinates']
    return [[lat, lon] for lon, lat in route_coords]

def get_ev_stations_near(lat, lon, radius_km=10):
    overpass_url = "http://overpass-api.de/api/interpreter"
    query = f"""
    [out:json];
    node
      ["amenity"="charging_station"]
      (around:{radius_km * 1000},{lat},{lon});
    out;
    """
    response = requests.post(overpass_url, data={'data': query})
    data = response.json()
    stations = [(node['lat'], node['lon']) for node in data['elements']]
    return stations

def get_all_stations_along_route(route_coords, interval=20, radius_km=10):
    sampled_stations = set()
    for i in range(0, len(route_coords), interval):
        lat, lon = route_coords[i]
        try:
            stations = get_ev_stations_near(lat, lon, radius_km)
            for s in stations:
                sampled_stations.add((round(s[0], 5), round(s[1], 5)))
        except:
            continue
    return list(sampled_stations)

def predict_battery_drain(route_coords, vehicle_range_km=300):
    total_distance = 0
    for i in range(1, len(route_coords)):
        total_distance += geodesic(route_coords[i-1], route_coords[i]).km

    battery_capacity = 100  # %
    predicted_drain = min((total_distance / vehicle_range_km) * 100, 100)
    remaining_soc = max(100 - predicted_drain, 0)

    return round(total_distance, 2), round(predicted_drain, 2), round(remaining_soc, 2)

def plot_route(route_coords, start_coord, end_coord, stations):
    midpoint = route_coords[len(route_coords)//2]
    m = folium.Map(location=midpoint, zoom_start=10)

    folium.Marker(location=start_coord, popup="Start", icon=folium.Icon(color='green')).add_to(m)
    folium.Marker(location=end_coord, popup="End", icon=folium.Icon(color='red')).add_to(m)
    folium.PolyLine(locations=route_coords, color='blue', weight=5).add_to(m)

    for station in stations:
        folium.Marker(location=station, icon=folium.Icon(color='orange'), popup='EV Charger').add_to(m)

    return m

# Step 3: Convert place name to coordinates using Nominatim
def get_coordinates(place):
    url = f"https://nominatim.openstreetmap.org/search?q={place}&format=json&limit=1"
    response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
    data = response.json()
    if data:
        return float(data[0]['lat']), float(data[0]['lon'])
    else:
        raise ValueError(f"Location not found: {place}")

# Re-import essential libraries
import requests
import folium
from geopy.distance import geodesic
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

# Install required packages
!pip install -q folium geopy requests scikit-learn

# Import all libraries
import requests
import folium
from geopy.distance import geodesic
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

# Get coordinates from location name
def get_coordinates(place):
    url = f"https://nominatim.openstreetmap.org/search?q={place}&format=json&limit=1"
    response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
    data = response.json()
    if data:
        return float(data[0]['lat']), float(data[0]['lon'])
    else:
        raise ValueError(f"Location not found: {place}")

# Get shortest route from OSRM
def get_osrm_route(start_coord, end_coord):
    base_url = "http://router.project-osrm.org/route/v1/driving/"
    coordinates = f"{start_coord[1]},{start_coord[0]};{end_coord[1]},{end_coord[0]}"
    url = f"{base_url}{coordinates}?overview=full&geometries=geojson"
    response = requests.get(url)
    data = response.json()
    route_coords = data['routes'][0]['geometry']['coordinates']
    return [[lat, lon] for lon, lat in route_coords]

# Get EV charging stations from Overpass API
def get_ev_stations_near(lat, lon, radius_km=10):
    overpass_url = "http://overpass-api.de/api/interpreter"
    query = f"""
    [out:json];
    node
      ["amenity"="charging_station"]
      (around:{radius_km * 1000},{lat},{lon});
    out;
    """
    response = requests.post(overpass_url, data={'data': query})
    data = response.json()
    stations = [(node['lat'], node['lon']) for node in data['elements']]
    return stations

# Get all stations along the route
def get_all_stations_along_route(route_coords, interval=20, radius_km=10):
    sampled_stations = set()
    for i in range(0, len(route_coords), interval):
        lat, lon = route_coords[i]
        try:
            stations = get_ev_stations_near(lat, lon, radius_km)
            for s in stations:
                sampled_stations.add((round(s[0], 5), round(s[1], 5)))
        except:
            continue
    return list(sampled_stations)

# Predict battery drain based on route distance
def predict_battery_drain(route_coords, vehicle_range_km=300):
    total_distance = 0
    for i in range(1, len(route_coords)):
        total_distance += geodesic(route_coords[i-1], route_coords[i]).km
    battery_capacity = 100  # in %
    predicted_drain = min((total_distance / vehicle_range_km) * 100, 100)
    remaining_soc = max(100 - predicted_drain, 0)
    return round(total_distance, 2), round(predicted_drain, 2), round(remaining_soc, 2)

# Plot map with route and charging stations
def plot_route(route_coords, start_coord, end_coord, stations):
    midpoint = route_coords[len(route_coords)//2]
    m = folium.Map(location=midpoint, zoom_start=10)
    folium.Marker(location=start_coord, popup="Start", icon=folium.Icon(color='green')).add_to(m)
    folium.Marker(location=end_coord, popup="End", icon=folium.Icon(color='red')).add_to(m)
    folium.PolyLine(locations=route_coords, color='blue', weight=5).add_to(m)
    for station in stations:
        folium.Marker(location=station, icon=folium.Icon(color='orange'), popup='EV Charger').add_to(m)
    return m

# MAIN RUN: Edit this to change cities
start = "Bangalore"
end = "Mysore"

start_coord = get_coordinates(start)
end_coord = get_coordinates(end)

route_coords = get_osrm_route(start_coord, end_coord)

distance_km, drain, soc = predict_battery_drain(route_coords)
print(f"Total Distance: {distance_km} km")
print(f"Estimated Battery Drain: {drain}%")
print(f"Remaining SoC on Arrival: {soc}%")

stations = get_all_stations_along_route(route_coords, interval=20, radius_km=10)
print(f"{len(stations)} charging stations found along the route.")

map_obj = plot_route(route_coords, start_coord, end_coord, stations)
map_obj

def find_nearest_charging_station(current_coord, stations):
    min_distance = float('inf')
    nearest_station = None

    for station in stations:
        distance = geodesic(current_coord, station).km
        if distance < min_distance:
            min_distance = distance
            nearest_station = station

    return nearest_station, round(min_distance, 2)

# MAIN RUN: Edit cities
start = "Bangalore"
end = "Chennai"

start_coord = get_coordinates(start)
end_coord = get_coordinates(end)

route_coords = get_osrm_route(start_coord, end_coord)

distance_km, drain, soc = predict_battery_drain(route_coords)
print(f"Total Distance: {distance_km} km")
print(f"Estimated Battery Drain: {drain}%")
print(f"Remaining SoC on Arrival: {soc}%")

stations = get_all_stations_along_route(route_coords, interval=20, radius_km=10)
print(f"{len(stations)} charging stations found along the route.")

# Check if battery is too low
charging_stop = None
if drain >= 90:
    charging_stop, dist_to_stop = find_nearest_charging_station(route_coords[len(route_coords)//2], stations)
    print(f"⚠️ Battery too low! Suggest stopping at nearby charging station ({dist_to_stop} km away)")

# Map it
midpoint = route_coords[len(route_coords)//2]
m = folium.Map(location=midpoint, zoom_start=10)
folium.Marker(location=start_coord, popup="Start", icon=folium.Icon(color='green')).add_to(m)
folium.Marker(location=end_coord, popup="End", icon=folium.Icon(color='red')).add_to(m)
folium.PolyLine(locations=route_coords, color='blue', weight=5).add_to(m)

for station in stations:
    folium.Marker(location=station, icon=folium.Icon(color='orange'), popup='EV Charger').add_to(m)

# Add suggested charging stop if needed
if charging_stop:
    folium.Marker(location=charging_stop, popup='⚡ Suggested Charging Stop',
                  icon=folium.Icon(color='yellow', icon='info-sign')).add_to(m)

m

# Install required packages
!pip install -q folium geopy requests scikit-learn

# Import all libraries
import requests
import folium
from geopy.distance import geodesic
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

# Get coordinates from location name
def get_coordinates(place):
    url = f"https://nominatim.openstreetmap.org/search?q={place}&format=json&limit=1"
    response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
    data = response.json()
    if data:
        return float(data[0]['lat']), float(data[0]['lon'])
    else:
        raise ValueError(f"Location not found: {place}")

# Get shortest route from OSRM
def get_osrm_route(start_coord, end_coord):
    base_url = "http://router.project-osrm.org/route/v1/driving/"
    coordinates = f"{start_coord[1]},{start_coord[0]};{end_coord[1]},{end_coord[0]}"
    url = f"{base_url}{coordinates}?overview=full&geometries=geojson"
    response = requests.get(url)
    data = response.json()
    route_coords = data['routes'][0]['geometry']['coordinates']
    return [[lat, lon] for lon, lat in route_coords]

# Get EV charging stations from Overpass API
def get_ev_stations_near(lat, lon, radius_km=10):
    overpass_url = "http://overpass-api.de/api/interpreter"
    query = f"""
    [out:json];
    node
      ["amenity"="charging_station"]
      (around:{radius_km * 1000},{lat},{lon});
    out;
    """
    response = requests.post(overpass_url, data={'data': query})
    data = response.json()
    stations = [(node['lat'], node['lon']) for node in data['elements']]
    return stations

# Get all stations along the route
def get_all_stations_along_route(route_coords, interval=20, radius_km=10):
    sampled_stations = set()
    for i in range(0, len(route_coords), interval):
        lat, lon = route_coords[i]
        try:
            stations = get_ev_stations_near(lat, lon, radius_km)
            for s in stations:
                sampled_stations.add((round(s[0], 5), round(s[1], 5)))
        except:
            continue
    return list(sampled_stations)

# Predict battery drain based on route distance
def predict_battery_drain(route_coords, vehicle_range_km=300):
    total_distance = 0
    for i in range(1, len(route_coords)):
        total_distance += geodesic(route_coords[i-1], route_coords[i]).km
    battery_capacity = 100  # in %
    predicted_drain = min((total_distance / vehicle_range_km) * 100, 100)
    remaining_soc = max(100 - predicted_drain, 0)
    return round(total_distance, 2), round(predicted_drain, 2), round(remaining_soc, 2)

# Find nearest charging station from a point
def find_nearest_charging_station(current_coord, stations):
    min_distance = float('inf')
    nearest_station = None
    for station in stations:
        distance = geodesic(current_coord, station).km
        if distance < min_distance:
            min_distance = distance
            nearest_station = station
    return nearest_station, round(min_distance, 2)

# Plot map with route and charging stations (highlight suggestion)
def plot_route(route_coords, start_coord, end_coord, stations, charging_stop=None):
    midpoint = route_coords[len(route_coords)//2]
    m = folium.Map(location=midpoint, zoom_start=10)
    folium.Marker(location=start_coord, popup="Start", icon=folium.Icon(color='green')).add_to(m)
    folium.Marker(location=end_coord, popup="End", icon=folium.Icon(color='red')).add_to(m)
    folium.PolyLine(locations=route_coords, color='blue', weight=5).add_to(m)

    for station in stations:
        folium.Marker(location=station, icon=folium.Icon(color='orange'), popup='EV Charger').add_to(m)

    if charging_stop:
        folium.Marker(location=charging_stop, popup='⚡ Suggested Charging Stop',
                      icon=folium.Icon(color='yellow')).add_to(m)

    return m

# MAIN RUN: Change city names here
start = "Bangalore"
end = "Chennai"

# Get coordinates
start_coord = get_coordinates(start)
end_coord = get_coordinates(end)

# Get route
route_coords = get_osrm_route(start_coord, end_coord)

# Predict battery drain
distance_km, drain, soc = predict_battery_drain(route_coords)
print(f"Total Distance: {distance_km} km")
print(f"Estimated Battery Drain: {drain}%")
print(f"Remaining SoC on Arrival: {soc}%")

# Find charging stations
stations = get_all_stations_along_route(route_coords, interval=20, radius_km=10)
print(f"{len(stations)} charging stations found along the route.")

# Suggest charging stop if battery drain is high
charging_stop = None
if drain >= 90:
    charging_stop, dist_to_stop = find_nearest_charging_station(route_coords[len(route_coords)//2], stations)
    if charging_stop:
        print(f"⚠️ Battery low. Suggest charging stop at {charging_stop} ({dist_to_stop} km away)")

# Plot everything
map_obj = plot_route(route_coords, start_coord, end_coord, stations, charging_stop)
map_obj

!pip install -q plotly ipywidgets

import plotly.graph_objects as go
import ipywidgets as widgets
from IPython.display import display, clear_output
import time

def display_dashboard(speed, rpm, battery, range_left, charging):
    fig = go.Figure()

    # Speedometer
    fig.add_trace(go.Indicator(
        mode="gauge+number",
        value=speed,
        domain={'x': [0.0, 0.48], 'y': [0, 0.9]},
        title={'text': "Speed (km/h)"},
        gauge={'axis': {'range': [0, 240]}, 'bar': {'color': "blue"}}
    ))

    # RPM
    fig.add_trace(go.Indicator(
        mode="gauge+number",
        value=rpm,
        domain={'x': [0.52, 1], 'y': [0, 0.9]},
        title={'text': "RPM (x1000)"},
        gauge={'axis': {'range': [0, 10]}, 'bar': {'color': "orange"}}
    ))

    # Battery SoC
    fig.add_trace(go.Indicator(
        mode="number+gauge",
        value=battery,
        domain={'x': [0, 0.5], 'y': [0.95, 1.2]},
        title={'text': "Battery SoC (%)"},
        gauge={'shape': "bullet", 'axis': {'range': [0, 100]}, 'bar': {'color': "green"}}
    ))

    # Range Left
    fig.add_trace(go.Indicator(
        mode="number+gauge",
        value=range_left,
        domain={'x': [0.52, 1], 'y': [0.95, 1.2]},
        title={'text': "Range Left (km)"},
        gauge={'shape': "bullet", 'axis': {'range': [0, 500]}, 'bar': {'color': "purple"}}
    ))

    fig.update_layout(height=600, width=800, margin=dict(t=20, b=20))
    fig.show()

    if charging:
        print("⚡ Charging: ON")
    else:
        print("Charging: OFF")

# Live simulation controls
speed_slider = widgets.IntSlider(value=80, min=0, max=240, step=5, description='Speed')
rpm_slider = widgets.FloatSlider(value=3.5, min=0, max=10, step=0.1, description='RPM (x1000)')
battery_slider = widgets.IntSlider(value=85, min=0, max=100, step=1, description='Battery %')
range_slider = widgets.IntSlider(value=220, min=0, max=500, step=10, description='Range (km)')
charging_toggle = widgets.ToggleButton(value=False, description='Charging On/Off')

ui = widgets.VBox([speed_slider, rpm_slider, battery_slider, range_slider, charging_toggle])

def display_dashboard(speed, rpm, battery, range_left, charging):
    fig = go.Figure()

    # Speedometer
    fig.add_trace(go.Indicator(
        mode="gauge+number",
        value=speed,
        domain={'x': [0.0, 0.48], 'y': [0.4, 1]},
        title={'text': "Speed (km/h)"},
        gauge={'axis': {'range': [0, 240]}, 'bar': {'color': "blue"}}
    ))

    # RPM
    fig.add_trace(go.Indicator(
        mode="gauge+number",
        value=rpm,
        domain={'x': [0.52, 1], 'y': [0.4, 1]},
        title={'text': "RPM (x1000)"},
        gauge={'axis': {'range': [0, 10]}, 'bar': {'color': "orange"}}
    ))

    # Battery SoC
    fig.add_trace(go.Indicator(
        mode="number+gauge",
        value=battery,
        domain={'x': [0.0, 0.48], 'y': [0.0, 0.35]},
        title={'text': "Battery SoC (%)"},
        gauge={'shape': "bullet", 'axis': {'range': [0, 100]}, 'bar': {'color': "green"}}
    ))

    # Range Left
    fig.add_trace(go.Indicator(
        mode="number+gauge",
        value=range_left,
        domain={'x': [0.52, 1], 'y': [0.0, 0.35]},
        title={'text': "Range Left (km)"},
        gauge={'shape': "bullet", 'axis': {'range': [0, 500]}, 'bar': {'color': "purple"}}
    ))

    fig.update_layout(height=600, width=800, margin=dict(t=20, b=20))
    fig.show()

    if charging:
        print("⚡ Charging: ON")
    else:
        print("Charging: OFF")

def display_dashboard(speed, rpm, battery, range_left, charging):
    fig = go.Figure()

    # Speedometer
    fig.add_trace(go.Indicator(
        mode="gauge+number",
        value=speed,
        domain={'x': [0.0, 0.48], 'y': [0.4, 1]},
        title={'text': "Speed (km/h)"},
        gauge={'axis': {'range': [0, 240]}, 'bar': {'color': "blue"}}
    ))

    # RPM
    fig.add_trace(go.Indicator(
        mode="gauge+number",
        value=rpm,
        domain={'x': [0.52, 1], 'y': [0.4, 1]},
        title={'text': "RPM (x1000)"},
        gauge={'axis': {'range': [0, 10]}, 'bar': {'color': "orange"}}
    ))

    # Battery SoC
    fig.add_trace(go.Indicator(
        mode="number+gauge",
        value=battery,
        domain={'x': [0.0, 0.48], 'y': [0.0, 0.35]},
        title={'text': "Battery SoC (%)"},
        gauge={'shape': "bullet", 'axis': {'range': [0, 100]}, 'bar': {'color': "green"}}
    ))

    # Range Left
    fig.add_trace(go.Indicator(
        mode="number+gauge",
        value=range_left,
        domain={'x': [0.52, 1], 'y': [0.0, 0.35]},
        title={'text': "Range Left (km)"},
        gauge={'shape': "bullet", 'axis': {'range': [0, 500]}, 'bar': {'color': "purple"}}
    ))

    fig.update_layout(height=600, width=800, margin=dict(t=20, b=20))
    fig.show()

    print("⚡ Charging: ON" if charging else "Charging: OFF")

# Control widgets
speed_slider = widgets.IntSlider(value=80, min=0, max=240, step=5, description='Speed')
rpm_slider = widgets.FloatSlider(value=3.5, min=0, max=10, step=0.1, description='RPM (x1000)')
battery_slider = widgets.IntSlider(value=85, min=0, max=100, step=1, description='Battery %')
range_slider = widgets.IntSlider(value=220, min=0, max=500, step=10, description='Range (km)')
charging_toggle = widgets.ToggleButton(value=False, description='Charging On/Off')

ui = widgets.VBox([speed_slider, rpm_slider, battery_slider, range_slider, charging_toggle])

from collections import deque

# Rolling history storage
time_window = 30  # seconds to display
speed_history = deque(maxlen=time_window)
rpm_history = deque(maxlen=time_window)
time_axis = deque(maxlen=time_window)
t = 0

def plot_live_speed_rpm(time_axis, speed_data, rpm_data):
    fig = go.Figure()

    # Speed line
    fig.add_trace(go.Scatter(x=list(time_axis), y=list(speed_data), mode='lines+markers', name='Speed (km/h)', line=dict(color='blue')))

    # RPM line
    fig.add_trace(go.Scatter(x=list(time_axis), y=list(rpm_data), mode='lines+markers', name='RPM (x1000)', line=dict(color='orange')))

    fig.update_layout(title='Live Speed & RPM Over Time',
                      xaxis_title='Time (s)',
                      yaxis_title='Value',
                      xaxis=dict(range=[max(0, t-30), t]),
                      height=400, width=800)
    fig.show()

def update_dashboard(change=None):
    global t
    clear_output(wait=True)

    # Collect current values
    speed_val = speed_slider.value
    rpm_val = rpm_slider.value

    # Add to history
    speed_history.append(speed_val)
    rpm_history.append(rpm_val)
    time_axis.append(t)
    t += 1

    # Display widgets and dashboards
    display(ui)
    display_dashboard(speed_val, rpm_val, battery_slider.value, range_slider.value, charging_toggle.value)
    plot_live_speed_rpm(time_axis, speed_history, rpm_history)

import random
from collections import deque
import plotly.graph_objects as go
import time
from IPython.display import clear_output

# Set up time-series tracking
time_window = 30
speed_data = deque(maxlen=time_window)
rpm_data = deque(maxlen=time_window)
time_data = deque(maxlen=time_window)

t = 0

# Simulate & Plot Loop
for _ in range(60):  # Run for 60 seconds
    # Simulate values (replace with actual slider values if needed)
    speed = random.randint(30, 120)
    rpm = round(random.uniform(1.0, 6.0), 2)

    # Store
    speed_data.append(speed)
    rpm_data.append(rpm)
    time_data.append(t)
    t += 1

    # Plot
    clear_output(wait=True)
    fig = go.Figure()

    fig.add_trace(go.Scatter(x=list(time_data), y=list(speed_data),
                             mode='lines+markers', name='Speed (km/h)', line=dict(color='blue')))
    fig.add_trace(go.Scatter(x=list(time_data), y=list(rpm_data),
                             mode='lines+markers', name='RPM (x1000)', line=dict(color='orange')))

    fig.update_layout(title='Live Speed & RPM Over Time',
                      xaxis_title='Time (s)',
                      yaxis_title='Value',
                      xaxis=dict(range=[max(0, t-30), t]),
                      height=400, width=800)

    fig.show()
    time.sleep(1)

import pandas as pd
import random
from collections import deque
import plotly.graph_objects as go
import time
from IPython.display import clear_output

# Set up time-series tracking
time_window = 30
speed_data = deque(maxlen=time_window)
rpm_data = deque(maxlen=time_window)
time_data = deque(maxlen=time_window)

# Set up log DataFrame
log_data = []

t = 0

# Simulate for 60 seconds
for _ in range(60):
    # Simulate values
    speed = random.randint(30, 120)
    rpm = round(random.uniform(1.0, 6.0), 2)

    # Store in real-time chart queues
    speed_data.append(speed)
    rpm_data.append(rpm)
    time_data.append(t)

    # Log to list
    log_data.append({
        "Time (s)": t,
        "Speed (km/h)": speed,
        "RPM (x1000)": rpm,
        "Timestamp": time.strftime('%H:%M:%S')
    })

    # Plot
    clear_output(wait=True)
    fig = go.Figure()

    fig.add_trace(go.Scatter(x=list(time_data), y=list(speed_data),
                             mode='lines+markers', name='Speed (km/h)', line=dict(color='blue')))
    fig.add_trace(go.Scatter(x=list(time_data), y=list(rpm_data),
                             mode='lines+markers', name='RPM (x1000)', line=dict(color='orange')))

    fig.update_layout(title='Live Speed & RPM Over Time',
                      xaxis_title='Time (s)',
                      yaxis_title='Value',
                      xaxis=dict(range=[max(0, t-30), t]),
                      height=400, width=800)

    fig.show()
    t += 1
    time.sleep(1)

# Create DataFrame
log_df = pd.DataFrame(log_data)

# Show first few rows
log_df.head()

from google.colab import sheets
sheet = sheets.InteractiveSheet(df=log_df)